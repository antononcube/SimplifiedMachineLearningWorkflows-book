---
title: "Dimension reduction methods comparison (Python)"
author: Anton Antonov
date: 2021-11-25
output: html_notebook
---

<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, echo=FALSE}
library(tidyverse)
library(skimr)

Sys.setenv(RETICULATE_PYTHON = "~/miniforge3/envs/SciPyCentric/bin/python")
library(reticulate)
reticulate::use_condaenv("SciPyCentric")
```

```{r, echo=FALSE, include=FALSE}
reticulate::py_config()
```

------

# Introduction

This notebook shows how to use Latent Semantic Analysis (LSA) for deriving "topics" of images.


------

# Setup Python packages

Load necessary Python package and modules:

```{python}
# "Standard" packages
import pandas
import numpy
import io
import time

# WolframClient packages
# Needed for random mandala images generation
from wolframclient.evaluation import WolframLanguageSession
from wolframclient.language import wl

# SSparseMatrix, SMR, and LSA packages
from SSparseMatrix import *
from SparseMatrixRecommender import *
from LatentSemanticAnalyzer import LatentSemanticAnalyzer

# Plotting packages
import matplotlib
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import ImageGrid

# Image processing package(s)
from PIL import Image, ImageOps
```

-------

# Generate random mandalas data

Start Wolfram Kernel session:

```{python}
session = WolframLanguageSession()
```

Generate a (large) list of random mandalas using the function Wolfram Function Repository function
[`RandomMandala`](https://resources.wolframcloud.com/FunctionRepository/resources/RandomMandala/)
evaluated in the Wolfram Kernel through the 
[Python Wolfram Client](https://reference.wolfram.com/language/WolframClientForPython/).

```{python}
start = time.time()
numberOfMandalas = 200
imageSize = 100
mandalas = [session.evaluate(wl.ExportByteArray(
    wl.Image(
        wl.ResourceFunction("RandomMandala")(
            wl.Rule("Radius", 10),
            wl.Rule("RotationalSymmetryOrder", 6),
            wl.Rule("ConnectingFunction", wl.Composition(wl.FilledCurve, wl.BezierCurve)),
            wl.Rule(wl.ImageSize, imageSize)
        )
    ),
    'PNG')) for i in range(numberOfMandalas)]
end = time.time()
print("\n\t\tGeneration time : ", end-start)  
```

Show one of the random mandalas:

```{python}
img = Image.open(io.BytesIO(mandalas[0]))
# img.show() # Floating
imgplot = plt.imshow(img)
plt.show()
```

Invert the images:

```{python}
mandalas2 = [ImageOps.invert(Image.open(io.BytesIO(x))) for x in mandalas]
```

Binarize the images:

```{python}
mandalas3 = [im.convert('1') for im in mandalas2]
```

Show an array of inverted random mandalas:

```{r}
options(reticulate.repl.quiet = FALSE)
```

```{python}
# Following https://matplotlib.org/stable/gallery/axes_grid1/simple_axesgrid.html
fig = plt.figure(figsize=(10., 10.))
grid = ImageGrid(fig, 111,
                 nrows_ncols=(10, 10),
                 axes_pad=0.1, 
                 )

for ax, img in zip(grid, mandalas3):
    ax.imshow(img)
    ax.set(xticks=[], yticks=[])
    
plt.show()
```
Convert each image into array and flatten that array:

```{python}
mandala_arrays = [numpy.asarray(x, dtype="int32") for x in mandalas3]
```

Show the unique shapes and corresponding counts:

```{python}
shapes = [x.shape for x in mandala_arrays]
unique, counts = numpy.unique(shapes, return_counts=True)
unique
counts
```


```{python}
mandalaMat = [x.reshape(x.shape[0] * x.shape[1]) for x in mandala_arrays]
mandalaMat = numpy.array(mandalaMat)
mandalaMat.shape
```

Make `SSparseMatrix` object:

```{python}
mandalaSMat = SSparseMatrix(mandalaMat, row_names="", column_names="")
print(repr(mandalaSMat))
```

-------

# LSA object creation

```{python}
start = time.time()
lsaObj = LatentSemanticAnalyzer().set_document_term_matrix(mandalaSMat).apply_term_weight_functions("None", "None", "None")
end = time.time()
print("\n\t\tCreation time : ", end-start)          
```


The LSA object summary:

```{python}
print(repr(lsaObj))
```

------

# Extract topics

Here we extract image topics using 
[Singular Value Decomposition (SVD)](https://en.wikipedia.org/wiki/Singular_value_decomposition):

```{python}
numberOfTopics = 40
start = time.time() 
lsaObj = lsaObj.extract_topics(number_of_topics=numberOfTopics, min_number_of_documents_per_term=0, method="SVD", max_steps=50)
svdH = lsaObj.normalize_matrix_product(normalize_left=False).take_H().copy()
end = time.time()
print("\n\t\tTopic extraction time SVD : ", end-start)      
```

Here we extract image topics using 
[Non-Negative Matrix Factorization (NNMF)](https://en.wikipedia.org/wiki/Non-negative_matrix_factorization):

```{python}
start = time.time() 
lsaObj = lsaObj.extract_topics(number_of_topics=numberOfTopics, min_number_of_documents_per_term=0, method="NNMF", max_steps=12)
nnmfH = lsaObj.normalize_matrix_product(normalize_left=False).take_H().copy()
end = time.time()
print("\n\t\tTopic extraction time NNMF : ", end-start)      
```

The LSA object summary:

```{python}
print(repr(lsaObj))
```

Show the topics matrices:

```{python}
svdH
nnmfH
```

```{python}
print(repr(svdH))
print(repr(nnmfH))
```


```{python}
svdH2 = apply_term_weight_functions(doc_term_matrix=svdH, global_weight_func="None", local_weight_func="None", normalizer_func="AbsMax")
nnmfH2 = apply_term_weight_functions(doc_term_matrix=nnmfH, global_weight_func="None", local_weight_func="None", normalizer_func="AbsMax")
```


```{python}
svdArrTopic = numpy.array(svdH2[0,:].sparse_matrix().todense()).reshape(imageSize*imageSize)
nnmfArrTopic = numpy.array(nnmfH2[0,:].sparse_matrix().todense()).reshape(imageSize*imageSize)
```

------

# Show topics interpretation

Get the topics matrix from the LSA object and convert it into a dense array:

```{python}
svdTopicsArray = svdH2.sparse_matrix().todense()
svdTopicsArray.shape

nnmfTopicsArray = nnmfH2.sparse_matrix().todense()
nnmfTopicsArray.shape
```

Obtain topics interpretation images:

```{python}
svdTopicImages = [(255 - svdTopicsArray[i,:]*255).reshape(imageSize, imageSize) for i in range(svdTopicsArray.shape[0])]
svdTopicImages2 = [Image.fromarray(x) for x in svdTopicImages]

nnmfTopicImages = [(255 - nnmfTopicsArray[i,:]*255).reshape(imageSize, imageSize) for i in range(nnmfTopicsArray.shape[0])]
nnmfTopicImages2 = [Image.fromarray(x) for x in nnmfTopicImages]
```

Show SVD topics:

```{python}
fig = plt.figure(figsize=(10., 10.))
grid = ImageGrid(fig, 111,
                 nrows_ncols=(4, int(numberOfTopics/4)),
                 axes_pad=0.1,
                 )

for ax, img in zip(grid, svdTopicImages2):
    ax.imshow(img)
    ax.set(xticks=[], yticks=[])

plt.show()
```


Show NNMF topics:

```{python}
fig = plt.figure(figsize=(10., 10.))
grid = ImageGrid(fig, 111,
                 nrows_ncols=(4, int(numberOfTopics/4)),
                 axes_pad=0.1,
                 )

for ax, img in zip(grid, nnmfTopicImages2):
    ax.imshow(img)
    ax.set(xticks=[], yticks=[])

plt.show()
```
